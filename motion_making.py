#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Split HumanML3D new_joints motions into per-id folders using a FIXED joint-index mapping.

Input:
  - Directory containing *.npy files, each is new_joints with shape (T, J, 3) (typically J=21)

Output (per motion id):
  save_dir/<id>/
    - holistic.npy
    - right_arm.npy
    - left_arm.npy
    - right_leg.npy
    - left_leg.npy
    - torso.npy
    - meta.json  (includes source path + PART_JOINTS used)

IMPORTANT:
- This script does NOT try to infer joint order.
- It uses the fixed mapping you validated visually.

Example run:
  python split_motion_by_fixed_part_joints.py \
    --new_joints_dir /mnt/e/research/motion_data/new_joints \
    --save_dir /mnt/e/research/motion_data/split_by_id \
    --pattern "*.npy"

Optional:
  --strict_J 21  (default=21)  # warn if J != 21 (still proceeds unless --error_on_J_mismatch)
  --error_on_J_mismatch        # if set, abort on J mismatch
"""

import argparse
import glob
import json
import os
from typing import Dict, List, Tuple

import numpy as np

# ---------------------------------------------------------
# FIXED mapping (validated)
# ---------------------------------------------------------
PART_JOINTS: Dict[str, List[int]] = {
    "left_leg":  [12, 13, 14, 15],
    "right_leg": [17, 18, 19, 20],
    "left_arm":  [11, 5, 6, 7],
    "right_arm": [16, 8, 9, 10],
    "torso":     [0, 1, 2, 3, 4, 12, 17],
}

PARTS = ["right_arm", "left_arm", "right_leg", "left_leg", "torso"]


def load_new_joints(npy_path: str) -> np.ndarray:
    x = np.load(npy_path, allow_pickle=True)
    if x.ndim != 3 or x.shape[-1] != 3:
        raise ValueError(f"[{npy_path}] Expected (T,J,3), got {x.shape}")
    return x


def validate_indices(part_joints: Dict[str, List[int]], J: int) -> Dict[str, List[int]]:
    """
    Remove out-of-range indices safely (should not happen if mapping is correct).
    """
    cleaned: Dict[str, List[int]] = {}
    for part, idxs in part_joints.items():
        good = [int(i) for i in idxs if 0 <= int(i) < J]
        if len(good) != len(idxs):
            bad = [int(i) for i in idxs if not (0 <= int(i) < J)]
            print(f"[WARN] Out-of-range indices removed for {part}: {bad} (J={J})")
        cleaned[part] = good
    return cleaned


def save_one_motion_as_parts_fixed(
    new_joints_path: str,
    save_dir: str,
    strict_J: int = 21,
    error_on_J_mismatch: bool = False,
) -> Tuple[str, str]:
    """
    Save one motion into:
      save_dir/<id>/holistic.npy
      save_dir/<id>/<part>.npy for each part in PARTS
      save_dir/<id>/meta.json

    Returns:
      (motion_id, out_folder)
    """
    x = load_new_joints(new_joints_path)
    T, J, C = x.shape

    if strict_J is not None and J != strict_J:
        msg = f"[J mismatch] {new_joints_path}: J={J} (expected {strict_J})"
        if error_on_J_mismatch:
            raise ValueError(msg)
        else:
            print(f"[WARN] {msg} (still proceeding)")

    # motion id from filename stem
    stem = os.path.splitext(os.path.basename(new_joints_path))[0]
    motion_id = stem

    out_folder = os.path.join(save_dir, motion_id)
    os.makedirs(out_folder, exist_ok=True)

    # 1) holistic
    holistic_path = os.path.join(out_folder, "holistic.npy")
    np.save(holistic_path, x)

    # 2) fixed part split
    part_joints = validate_indices(PART_JOINTS, J)

    for part in PARTS:
        idxs = part_joints.get(part, [])
        part_arr = x[:, idxs, :] if len(idxs) > 0 else np.zeros((T, 0, 3), dtype=x.dtype)
        np.save(os.path.join(out_folder, f"{part}.npy"), part_arr)

    # 3) meta.json
    meta = {
        "id": motion_id,
        "source": new_joints_path,
        "shape": [int(T), int(J), int(C)],
        "PART_JOINTS": part_joints,
        "notes": "Split generated by fixed PART_JOINTS mapping validated via visualization.",
    }
    with open(os.path.join(out_folder, "meta.json"), "w", encoding="utf-8") as f:
        json.dump(meta, f, ensure_ascii=False, indent=2)

    return motion_id, out_folder


def process_directory_new_joints(
    new_joints_dir: str,
    save_dir: str,
    pattern: str = "*.npy",
    strict_J: int = 21,
    error_on_J_mismatch: bool = False,
) -> None:
    os.makedirs(save_dir, exist_ok=True)
    paths = sorted(glob.glob(os.path.join(new_joints_dir, pattern)))

    if len(paths) == 0:
        raise FileNotFoundError(f"No files matched: {os.path.join(new_joints_dir, pattern)}")

    print(f"[INFO] Found {len(paths)} files in: {new_joints_dir}")
    print(f"[INFO] Saving to: {save_dir}")
    print("[INFO] Using fixed PART_JOINTS:")
    print(json.dumps(PART_JOINTS, indent=2))

    ok = 0
    fail = 0
    for i, p in enumerate(paths):
        try:
            motion_id, out_folder = save_one_motion_as_parts_fixed(
                new_joints_path=p,
                save_dir=save_dir,
                strict_J=strict_J,
                error_on_J_mismatch=error_on_J_mismatch,
            )
            ok += 1
            if i < 5:
                print(f"[OK] {motion_id} -> {out_folder}")
        except Exception as e:
            fail += 1
            print(f"[FAIL] {p}: {e}")

    print(f"[DONE] success={ok}, fail={fail}")


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--new_joints_dir", type=str, required=True, help="Directory containing new_joints *.npy files.")
    ap.add_argument("--save_dir", type=str, required=True, help="Output directory root.")
    ap.add_argument("--pattern", type=str, default="*.npy", help="Glob pattern (default: *.npy)")
    ap.add_argument("--strict_J", type=int, default=21, help="Expected joint count J (default: 21).")
    ap.add_argument("--error_on_J_mismatch", action="store_true", help="Abort if J != strict_J.")
    args = ap.parse_args()

    process_directory_new_joints(
        new_joints_dir=args.new_joints_dir,
        save_dir=args.save_dir,
        pattern=args.pattern,
        strict_J=args.strict_J,
        error_on_J_mismatch=args.error_on_J_mismatch,
    )


if __name__ == "__main__":
    main()
